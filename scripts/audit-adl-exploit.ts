/**
 * Security Audit: ADL (Auto-Deleveraging) Exploitation
 *
 * Try to force liquidations and exploit ADL mechanism:
 * 1. Create highly leveraged positions
 * 2. Crash price to trigger liquidations
 * 3. Try to exploit ADL force close mechanism
 * 4. Attempt to drain vault through bad debt
 */

import { Connection, Keypair, PublicKey, Transaction, ComputeBudgetProgram, sendAndConfirmTransaction, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getAssociatedTokenAddressSync, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { fetchSlab, parseEngine, parseConfig, parseUsedIndices, parseAccount, AccountKind } from "../src/solana/slab.js";
import { encodeKeeperCrank, encodePushOraclePrice, encodeTradeCpi, encodeWithdrawCollateral, encodeDepositCollateral } from "../src/abi/instructions.js";
import { buildAccountMetas, ACCOUNTS_KEEPER_CRANK, ACCOUNTS_PUSH_ORACLE_PRICE, ACCOUNTS_TRADE_CPI, ACCOUNTS_WITHDRAW_COLLATERAL, ACCOUNTS_DEPOSIT_COLLATERAL } from "../src/abi/accounts.js";
import { buildIx } from "../src/runtime/tx.js";
import fs from "fs";

const marketInfo = JSON.parse(fs.readFileSync("devnet-market.json", "utf-8"));
const PROGRAM_ID = new PublicKey(marketInfo.programId);
const SLAB = new PublicKey(marketInfo.slab);
const ORACLE = new PublicKey(marketInfo.oracle);
const VAULT = new PublicKey(marketInfo.vault);
const MINT = new PublicKey(marketInfo.mint);
const MATCHER_PROGRAM = new PublicKey(marketInfo.matcherProgramId);
const MATCHER_CTX = new PublicKey(marketInfo.lp.matcherContext);
const LP_PDA = new PublicKey(marketInfo.lp.pda);

const conn = new Connection("https://api.devnet.solana.com", "confirmed");
const payer = Keypair.fromSecretKey(
  new Uint8Array(JSON.parse(fs.readFileSync(process.env.HOME + "/.config/solana/id.json", "utf-8")))
);

const DELAY_MS = 2000;

async function delay(ms: number = DELAY_MS) {
  await new Promise(r => setTimeout(r, ms));
}

function log(msg: string) {
  console.log(`[${new Date().toISOString()}] ${msg}`);
}

async function getState() {
  await delay(500);
  const data = await fetchSlab(conn, SLAB);
  const vaultInfo = await conn.getAccountInfo(VAULT);
  return {
    config: parseConfig(data),
    engine: parseEngine(data),
    data,
    vaultBalance: vaultInfo ? vaultInfo.lamports / 1e9 : 0,
  };
}

async function pushPrice(priceUsd: number): Promise<boolean> {
  await delay();
  const priceE6 = BigInt(Math.round(priceUsd * 1_000_000));
  const timestamp = BigInt(Math.floor(Date.now() / 1000));
  const data = encodePushOraclePrice({ priceE6, timestamp });
  const keys = buildAccountMetas(ACCOUNTS_PUSH_ORACLE_PRICE, [payer.publicKey, SLAB]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 50_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    log(`PushPrice ${priceUsd} failed: ${e.message?.slice(0, 50)}`);
    return false;
  }
}

async function crank(): Promise<boolean> {
  await delay();
  const crankData = encodeKeeperCrank({ callerIdx: 65535, allowPanic: false });
  const crankKeys = buildAccountMetas(ACCOUNTS_KEEPER_CRANK, [
    payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE,
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 300000 }),
    buildIx({ programId: PROGRAM_ID, keys: crankKeys, data: crankData })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch { return false; }
}

async function trade(userIdx: number, lpIdx: number, size: bigint): Promise<boolean> {
  await delay();
  const tradeData = encodeTradeCpi({ userIdx, lpIdx, size });
  const tradeKeys = buildAccountMetas(ACCOUNTS_TRADE_CPI, [
    payer.publicKey, payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE,
    MATCHER_PROGRAM, MATCHER_CTX, LP_PDA,
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 200_000 }),
    buildIx({ programId: PROGRAM_ID, keys: tradeKeys, data: tradeData })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    log(`Trade failed: ${e.message?.slice(0, 80)}`);
    return false;
  }
}

async function withdraw(userIdx: number, amount: bigint): Promise<boolean> {
  await delay();
  const userAta = getAssociatedTokenAddressSync(MINT, payer.publicKey);
  const vaultPda = new PublicKey(marketInfo.vaultPda);
  const withdrawData = encodeWithdrawCollateral({ idx: userIdx, amount });
  const withdrawKeys = buildAccountMetas(ACCOUNTS_WITHDRAW_COLLATERAL, [
    payer.publicKey, SLAB, VAULT, userAta, vaultPda, TOKEN_PROGRAM_ID, SYSVAR_CLOCK_PUBKEY, ORACLE,
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),
    buildIx({ programId: PROGRAM_ID, keys: withdrawKeys, data: withdrawData })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch { return false; }
}

async function printAccountState(data: Buffer, idx: number) {
  const acc = parseAccount(data, idx);
  if (acc) {
    const kind = acc.kind === AccountKind.LP ? 'LP' : 'USER';
    log(`  [${idx}] ${kind}: capital=${(Number(acc.capital) / 1e9).toFixed(6)} pos=${acc.positionSize} avgEntry=${acc.avgEntryPrice}`);
  }
}

async function main() {
  log("=== ADL EXPLOITATION ATTACK TEST ===\n");

  // Initial state
  const { vaultBalance: v1, engine: e1, data: data1 } = await getState();
  const ins1 = Number(e1.insuranceFund.balance) / 1e9;
  const liq1 = Number(e1.lifetimeLiquidations);

  log(`Initial State:`);
  log(`  Vault: ${v1.toFixed(6)} SOL`);
  log(`  Insurance: ${ins1.toFixed(6)} SOL`);
  log(`  Lifetime liquidations: ${liq1}`);

  // Find accounts
  const indices = parseUsedIndices(data1);
  let userIdx = -1;
  let lpIdx = -1;

  for (const idx of indices) {
    const acc = parseAccount(data1, idx);
    if (acc) {
      if (acc.kind === AccountKind.User && acc.owner.equals(payer.publicKey)) {
        userIdx = idx;
      }
      if (acc.kind === AccountKind.LP) {
        lpIdx = idx;
      }
    }
  }

  log(`\nAccounts found: userIdx=${userIdx}, lpIdx=${lpIdx}`);

  if (userIdx < 0) {
    log("No user account found!");
    return;
  }

  log("\nInitial account states:");
  for (const idx of indices) {
    await printAccountState(data1, idx);
  }

  // ATTACK 1: Create maximum leverage position, then crash
  log("\n=== ATTACK 1: Maximum Leverage + Crash ===");

  // Set normal price and crank
  await pushPrice(150);
  for (let i = 0; i < 5; i++) await crank();

  // Try to open largest possible position
  log("Attempting to open large LONG position...");
  const positions = [1000000n, 2000000n, 5000000n, 10000000n];
  let openedPosition = 0n;

  for (const pos of positions) {
    const success = await trade(userIdx, 0, pos);
    if (success) {
      openedPosition = pos;
      log(`  Position ${pos} opened successfully`);
    } else {
      log(`  Position ${pos} rejected`);
      break;
    }
    await crank();
  }

  if (openedPosition > 0n) {
    log(`\nPosition opened: ${openedPosition}`);

    // Get state with position
    const { data: data2 } = await getState();
    log("Account state after opening position:");
    await printAccountState(data2, userIdx);

    // CRASH THE PRICE
    log("\nCrashing price to trigger liquidation...");
    const crashPrices = [100, 50, 20, 10, 5, 1];

    for (const p of crashPrices) {
      await pushPrice(p);
      log(`  Price set to $${p}`);

      // Heavy cranking to process liquidations
      for (let i = 0; i < 10; i++) {
        await crank();
      }

      // Check for liquidations
      const { engine: eMid, data: dataMid } = await getState();
      const liqMid = Number(eMid.lifetimeLiquidations);

      if (liqMid > liq1) {
        log(`  *** LIQUIDATION DETECTED! Count: ${liq1} -> ${liqMid} ***`);
      }

      // Check account state
      const accMid = parseAccount(dataMid, userIdx);
      if (accMid) {
        log(`  User state: capital=${(Number(accMid.capital) / 1e9).toFixed(6)} pos=${accMid.positionSize}`);

        if (accMid.positionSize === 0n && openedPosition !== 0n) {
          log(`  *** POSITION CLOSED (liquidated or ADL) ***`);
          break;
        }
      }

      // Try to withdraw during crash
      log(`  Attempting withdrawal during crash...`);
      const wResult = await withdraw(userIdx, 100000000n);
      log(`  Withdrawal: ${wResult ? "SUCCESS" : "BLOCKED"}`);
    }

    // RECOVER and try to exploit
    log("\nRecovering price...");
    await pushPrice(150);
    for (let i = 0; i < 10; i++) await crank();

    // Try to close any remaining position
    const { data: data3 } = await getState();
    const acc3 = parseAccount(data3, userIdx);
    if (acc3 && acc3.positionSize !== 0n) {
      log(`Closing remaining position: ${acc3.positionSize}`);
      await trade(userIdx, 0, -acc3.positionSize);
      await crank();
    }
  }

  // ATTACK 2: Try to create bad debt
  log("\n=== ATTACK 2: Bad Debt Creation ===");

  await pushPrice(150);
  await crank();

  // Try to open position, then crash to create bad debt
  log("Opening position for bad debt test...");
  const bdResult = await trade(userIdx, 0, 5000000n);

  if (bdResult) {
    await crank();

    // Extreme crash
    log("Extreme crash to $0.01...");
    await pushPrice(0.01);

    // Many cranks
    for (let i = 0; i < 20; i++) {
      await crank();
    }

    // Check insurance impact
    const { engine: e2 } = await getState();
    const ins2 = Number(e2.insuranceFund.balance) / 1e9;
    log(`Insurance: ${ins1.toFixed(6)} -> ${ins2.toFixed(6)} (Δ = ${(ins2 - ins1).toFixed(6)})`);

    if (ins2 < ins1 - 0.01) {
      log("*** WARNING: Insurance fund may have been used to cover bad debt! ***");
    }

    // Recover
    await pushPrice(150);
    for (let i = 0; i < 10; i++) await crank();

    // Close position if any
    const { data: data4 } = await getState();
    const acc4 = parseAccount(data4, userIdx);
    if (acc4 && acc4.positionSize !== 0n) {
      await trade(userIdx, 0, -acc4.positionSize);
      await crank();
    }
  }

  // ATTACK 3: Force ADL on other users
  log("\n=== ATTACK 3: ADL Cascade ===");

  // Check all accounts
  const { data: data5 } = await getState();
  log("Current account states:");
  for (const idx of indices) {
    await printAccountState(data5, idx);
  }

  // Try price manipulation to force ADL
  log("\nManipulating price to force ADL...");
  const adlPrices = [500, 1000, 50, 10, 500, 1000, 10, 1];

  for (const p of adlPrices) {
    await pushPrice(p);
    for (let i = 0; i < 5; i++) await crank();

    const { engine: eAdl } = await getState();
    const liqAdl = Number(eAdl.lifetimeLiquidations);
    if (liqAdl > liq1) {
      log(`  *** ADL/Liquidation at price $${p}! Count: ${liq1} -> ${liqAdl} ***`);
    }
  }

  // Final state
  log("\n=== FINAL STATE ===");
  await pushPrice(150);
  for (let i = 0; i < 10; i++) await crank();

  const { vaultBalance: v2, engine: e3, data: data6 } = await getState();
  const ins3 = Number(e3.insuranceFund.balance) / 1e9;
  const liq3 = Number(e3.lifetimeLiquidations);

  log(`Vault: ${v1.toFixed(6)} -> ${v2.toFixed(6)} (Δ = ${(v2 - v1).toFixed(6)})`);
  log(`Insurance: ${ins1.toFixed(6)} -> ${ins3.toFixed(6)} (Δ = ${(ins3 - ins1).toFixed(6)})`);
  log(`Liquidations: ${liq1} -> ${liq3}`);

  log("\nFinal account states:");
  for (const idx of indices) {
    await printAccountState(data6, idx);
  }

  // Summary
  log("\n=== SUMMARY ===");
  if (v2 < v1 - 0.01) {
    log("*** VULNERABILITY: Vault drained! ***");
  } else {
    log("Vault protected - no significant drain");
  }

  if (ins3 < ins1 - 0.01) {
    log("*** VULNERABILITY: Insurance drained! ***");
  } else {
    log("Insurance protected - no significant drain");
  }

  if (liq3 > liq1) {
    log(`Liquidations triggered: ${liq3 - liq1}`);
  } else {
    log("No liquidations triggered");
  }

  // Save results
  const results = {
    vaultBefore: v1,
    vaultAfter: v2,
    insuranceBefore: ins1,
    insuranceAfter: ins3,
    liquidationsBefore: liq1,
    liquidationsAfter: liq3,
    vaultDrained: v2 < v1 - 0.01,
    insuranceDrained: ins3 < ins1 - 0.01,
  };

  fs.writeFileSync("audit-adl-results.json", JSON.stringify(results, null, 2));
  log("\nResults saved to audit-adl-results.json");
}

main().catch(console.error);
